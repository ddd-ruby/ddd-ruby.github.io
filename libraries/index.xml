<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Libraries on DDD concepts with Ruby</title>
    <link>https://ddd-ruby.github.io/libraries/index.xml</link>
    <description>Recent content in Libraries on DDD concepts with Ruby</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MIT license</copyright>
    <lastBuildDate>Tue, 08 Mar 2016 21:07:13 +0100</lastBuildDate>
    <atom:link href="https://ddd-ruby.github.io/libraries/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Ruby libraries supporting DDD</title>
      <link>https://ddd-ruby.github.io/libraries/</link>
      <pubDate>Tue, 08 Mar 2016 21:07:13 +0100</pubDate>
      
      <guid>https://ddd-ruby.github.io/libraries/</guid>
      <description>

&lt;h2 id=&#34;rdm-the-missing-dependencies-manager-for-ruby-apps&#34;&gt;Rdm: the missing dependencies manager for Ruby apps&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ddd-ruby.github.io/rdm/&#34; target=&#34;_blank&#34;&gt;Rdm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With RDM you can split up one big Ruby application into multiple lightweight packages with explicit dependencies. You can do it before going the &lt;code&gt;microservices&lt;/code&gt; road, because this would be a much smoother transition. Going from explicit dependencies graph to proper SOA / microservices is also more straightforward. In DDD it helps to define clearer &lt;a href=&#34;http://martinfowler.com/bliki/BoundedContext.html&#34;&gt;Bounded Contexts&lt;/a&gt;, where each package can only access explicit dependencies. Contrast this with a monolithic Rails application with one global Ruby memory space, and you might understand the benefit of having stricter, more explicit way of managing dependencies.&lt;/p&gt;

&lt;h2 id=&#34;smartioc-a-declarative-dependency-injection-library&#34;&gt;SmartIoC: a declarative dependency Injection library&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ddd-ruby.github.io/smart_ioc/&#34; target=&#34;_blank&#34;&gt;SmartIoC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SmartIoC is a smart and really simple IoC container for Ruby applications.&lt;/p&gt;

&lt;p&gt;It allows you to create your dependencies on demand, supports lazy-loading of Ruby files, also allows different contexts for each dependency, so you get test/lightweight implementations in development / tests enviroments. It works great in combination with &lt;code&gt;Rdm&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;hcast-hash-attributes-caster-in-declarative-way&#34;&gt;Hcast - Hash attributes caster in declarative way&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ddd-ruby.github.io/hcast/&#34; target=&#34;_blank&#34;&gt;Hcast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the DDD context it helps to convert user input to a properly casted Ruby object / hash. It is a lightweight dependency-free Ruby library, with a nice DSL for for specifying the structure of expected input with Ruby types.&lt;/p&gt;

&lt;h2 id=&#34;contracts-contracts-for-ruby&#34;&gt;Contracts - Contracts for Ruby&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ddd-ruby.github.io/contracts.ruby/&#34; target=&#34;_blank&#34;&gt;Contracts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Contracts let you clearly – even beautifully – express how your code behaves, and free you from writing tons of boilerplate, defensive code.&lt;/p&gt;

&lt;p&gt;We have a forked version of &lt;code&gt;contracts&lt;/code&gt; with nice diff output for KeywordArgs type (Hash).&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>